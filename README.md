# Project Title

Python(3) based implementation of a utf-8 encoded text file compression using the [Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch) text file compression algorithm.


# Installing

These instructions will get you a copy of the project up and running on your local machine for development.

Firstly, the lzw package needs to be installed. I highly recommend using a virtual environment to install this package as it is a distutils install and not a pip one.
For information on virtual environments see [this](https://virtualenv.pypa.io/).

**Note**: Make sure you are using python3 and not python2. The version of python3 I used to build this project is python3.5.2 and I do not guarantee any backward/forward compatibility.

Open a new terminal window(recommended).

So, after cloning the repository, cd into the folder of the project and run the following command in the terminal:

``python3 setup.py install``

This completes the installation of the package. Now its time to use this package to achieve some compression.


# Getting started

There are **2 major classes** in the lzw package that form the functional API. First one is **compress** that resides in the **lzw.Compress** module and another is **decompress** which is defined in **lzw.Decompress** module. The basic steps in compression and decompression involve simply instantiating these classes with appropriate file names and paths and then calling the encode and decode methods on these objects respectively. Following sections provide a walkthrough of these steps in detail.

## Compression
First import the compress class as follows:

``from lzw.Compress import compress as comp``

Then create a compress object as follows:

``c = comp('/path/to/input/file','/desired/path/for/output/file'[[[,limit,is_text,verbose,chunks]]])``

**Note**: The input file must be in the utf-8 encoding format. Provide entire path as a string input to the class. Provide the path where the compressed file is to reside. Do not provide a filename as the output path. The name of the compressed file will default to a compressed.txt appended to your input file's name.
*limit*(default=20000000,type=int) is an optional argument which specifies the max size of the file to be compressed. The default is 20MB. The limit can be changed but note that larger files take substantially large times(as of now).
*is_text*(default=True) is to be set as False iff the file to be compressed is not a plain English text file. Basically, the program uses a initial dictionary of ASCII chars 0-255 if is_text=False. is_text is True by default, and the initial dictionary contains ASCII chars 0-127.
*verbose*(default=0,type=int) input, if set to 2, the program displays percent execution per chunk of input processed.
verbose=1 shows the execution time per chunk of input file processed.
Note: The verbose=2 option may generate large amounts of output on stdout and is 0
by default.
*chunks*(default=None,type=int) is an integer type argument used to specify the number of chunks in which the file is divided in during compression. By default, the program adoptively decides this number. chunks are useful for very large files as a single chunk is loaded into RAM during compression. The maximum value allowed is 100 chunks.

After the command runs successfully, the compress object is ready. The actual compresseion is triggered by calling the *encode* method on this object as follows:

``c.encode()  ``

Depending on the file size, this may take quite a while. The status is shown in the terminal window.
Once done, a new file is created in the path you mentioned which you can verify is decently compressed to about a third of its original size provided the original file was not trivially small.

## Decompression

The steps here are similar to that of compression.

Firstly, import the compress class as follows:

``from lzw.Decompress import decompress as decomp``

Next, create a decompress object as follows:

``d =  decomp('/path/to/compressed/file','/desired/path/for/decompressed/file'[[[,limit,is_text,verbose,chunks]]])``

**Note**: The first argument is the full path of the file to be decompressed. This file must have a .txt extension and must be a one generated by the compress class of this package. The desired path for the decompressed file is the second argument. Do not provide a file name here and give a full qualified path. The name of the decompressed file will default to a decompressed.txt appended to your input file's name.
*limit* is an optional(integer) argument which specifies the max size of the file to be decompressed. The default is 20MB. The limit can be changed but note that larger files take substantially large times(as of now).
*is_text*(default=True) is to be set False iff this same argument was False when the file was compressed.
*verbose*(default=0) is similar to the argument to lzw.Compress.compress __init__ argument *verbose*.
*chunks*(default=None,type=int) is an integer type argument used to specify the number of chunks in which the file is divided in during decompression. By default, the program adoptively decides this number. chunks are useful for very large files as a single chunk is loaded into RAM during decompression. The maximum value allowed is 100 chunks.

After the command runs successfully, the decompress object is ready. The actual decompresseion is triggered by calling the *decode* method on this object as follows:

``d.decode()  ``

Depending on the file size, this may take quite a while. The status is shown in the terminal window.
Once done, a new file is created in the path you mentioned which must be the same as the input file.

**Note**: The default extension for the decompressed file is *.txt*. You can suitably rename it to your desired format.


# Author

 **Prathamesh Mandke** - prathrules@gmail.com

# License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.
